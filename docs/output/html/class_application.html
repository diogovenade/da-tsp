<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA2024_PRJ2_G85: Application Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA2024_PRJ2_G85<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_application-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Application Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8bd10af3d61669eb3507acde812aeb58" id="r_a8bd10af3d61669eb3507acde812aeb58"><td class="memItemLeft" align="right" valign="top"><a id="a8bd10af3d61669eb3507acde812aeb58" name="a8bd10af3d61669eb3507acde812aeb58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Application</b> (int i)</td></tr>
<tr class="separator:a8bd10af3d61669eb3507acde812aeb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c59246a1d8ebdcad2e90b0f8ff04f1" id="r_ab0c59246a1d8ebdcad2e90b0f8ff04f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c59246a1d8ebdcad2e90b0f8ff04f1">tspBacktracking</a> ()</td></tr>
<tr class="memdesc:ab0c59246a1d8ebdcad2e90b0f8ff04f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines an optimal solution to the Travelling Salesman Problem.  <br /></td></tr>
<tr class="separator:ab0c59246a1d8ebdcad2e90b0f8ff04f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328fa3aafcf669ef64b19b0867f18689" id="r_a328fa3aafcf669ef64b19b0867f18689"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a328fa3aafcf669ef64b19b0867f18689">tspTriangular</a> ()</td></tr>
<tr class="memdesc:a328fa3aafcf669ef64b19b0867f18689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polynomial approximation algorithm that relies on the triangular inequality principle.  <br /></td></tr>
<tr class="separator:a328fa3aafcf669ef64b19b0867f18689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d7f62cef1825295f2012008a9fe963" id="r_ae6d7f62cef1825295f2012008a9fe963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d7f62cef1825295f2012008a9fe963">tspNearestNeighbor</a> ()</td></tr>
<tr class="memdesc:ae6d7f62cef1825295f2012008a9fe963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the nearest neighbor heuristic to solve the Travelling Salesman Problem.  <br /></td></tr>
<tr class="separator:ae6d7f62cef1825295f2012008a9fe963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cb77f46178b75187daa235a1d86f4f" id="r_a49cb77f46178b75187daa235a1d86f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49cb77f46178b75187daa235a1d86f4f">tspChristofides</a> ()</td></tr>
<tr class="memdesc:a49cb77f46178b75187daa235a1d86f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses Christofides' algorithm to solve the Travelling Salesman Problem.  <br /></td></tr>
<tr class="separator:a49cb77f46178b75187daa235a1d86f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca89af62d3a26510836f805d00ce7cab" id="r_aca89af62d3a26510836f805d00ce7cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca89af62d3a26510836f805d00ce7cab">tspRealWorld</a> (int source)</td></tr>
<tr class="memdesc:aca89af62d3a26510836f805d00ce7cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a nearest neighbor approach to solve the Travelling Salesman Problem in real-world scenarios.  <br /></td></tr>
<tr class="separator:aca89af62d3a26510836f805d00ce7cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9dd5f3b4e32963a69ed410037623f0df" id="r_a9dd5f3b4e32963a69ed410037623f0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dd5f3b4e32963a69ed410037623f0df">tspBacktrackingAux</a> (int currPos, int n, int count, float cost, float &amp;ans, std::vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a9dd5f3b4e32963a69ed410037623f0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function to backtracking algorithm.  <br /></td></tr>
<tr class="separator:a9dd5f3b4e32963a69ed410037623f0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d8561b2200eb51d2f7c275307a779" id="r_ad12d8561b2200eb51d2f7c275307a779"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad12d8561b2200eb51d2f7c275307a779">primMST</a> ()</td></tr>
<tr class="memdesc:ad12d8561b2200eb51d2f7c275307a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prim's algorithm to find Minimum Spanning Tree (MST) of graph.  <br /></td></tr>
<tr class="separator:ad12d8561b2200eb51d2f7c275307a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3818802badb48469bff5b57d56d9c13f" id="r_a3818802badb48469bff5b57d56d9c13f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3818802badb48469bff5b57d56d9c13f">preorderTraversal</a> (int root, std::vector&lt; bool &gt; &amp;visited)</td></tr>
<tr class="memdesc:a3818802badb48469bff5b57d56d9c13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a preorder traversal starting from a given root node.  <br /></td></tr>
<tr class="separator:a3818802badb48469bff5b57d56d9c13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac117d3080e629b82644b0c742e4d3df3" id="r_ac117d3080e629b82644b0c742e4d3df3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac117d3080e629b82644b0c742e4d3df3">haversineDistance</a> (<a class="el" href="class_vertex.html">Vertex</a> *v1, <a class="el" href="class_vertex.html">Vertex</a> *v2)</td></tr>
<tr class="memdesc:ac117d3080e629b82644b0c742e4d3df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines Haversine distance between two points.  <br /></td></tr>
<tr class="separator:ac117d3080e629b82644b0c742e4d3df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dd65d6e2541e496031126b75e9c1cb" id="r_ac1dd65d6e2541e496031126b75e9c1cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1dd65d6e2541e496031126b75e9c1cb">blossomAlgorithm</a> (const std::vector&lt; int &gt; &amp;oddVertices)</td></tr>
<tr class="memdesc:ac1dd65d6e2541e496031126b75e9c1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Blossom Algorithm to find perfect matching.  <br /></td></tr>
<tr class="separator:ac1dd65d6e2541e496031126b75e9c1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e3b1094459f877226540af1d8c3240" id="r_a04e3b1094459f877226540af1d8c3240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04e3b1094459f877226540af1d8c3240">findEulerianCircuit</a> (int u, std::vector&lt; int &gt; &amp;circuit)</td></tr>
<tr class="memdesc:a04e3b1094459f877226540af1d8c3240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Eulerian circuit in a graph.  <br /></td></tr>
<tr class="separator:a04e3b1094459f877226540af1d8c3240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81197bfa5340cd8dc6f3c9504abaa6af" id="r_a81197bfa5340cd8dc6f3c9504abaa6af"><td class="memItemLeft" align="right" valign="top"><a id="a81197bfa5340cd8dc6f3c9504abaa6af" name="a81197bfa5340cd8dc6f3c9504abaa6af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetGraph</b> ()</td></tr>
<tr class="separator:a81197bfa5340cd8dc6f3c9504abaa6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7d0a74b8b696cfdc5e5002dbb5bf7bb9" id="r_a7d0a74b8b696cfdc5e5002dbb5bf7bb9"><td class="memItemLeft" align="right" valign="top"><a id="a7d0a74b8b696cfdc5e5002dbb5bf7bb9" name="a7d0a74b8b696cfdc5e5002dbb5bf7bb9"></a>
<a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><b>graph</b></td></tr>
<tr class="separator:a7d0a74b8b696cfdc5e5002dbb5bf7bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9bb735289947ada0feafc06da4b7af" id="r_a0b9bb735289947ada0feafc06da4b7af"><td class="memItemLeft" align="right" valign="top"><a id="a0b9bb735289947ada0feafc06da4b7af" name="a0b9bb735289947ada0feafc06da4b7af"></a>
std::vector&lt; std::vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>distanceMatrix</b></td></tr>
<tr class="separator:a0b9bb735289947ada0feafc06da4b7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98d412757b190f78f41f247fc25aa94" id="r_aa98d412757b190f78f41f247fc25aa94"><td class="memItemLeft" align="right" valign="top"><a id="aa98d412757b190f78f41f247fc25aa94" name="aa98d412757b190f78f41f247fc25aa94"></a>
std::vector&lt; std::vector&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>visited</b></td></tr>
<tr class="separator:aa98d412757b190f78f41f247fc25aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bc02c1de12e043494c6d54e7fb93af" id="r_a69bc02c1de12e043494c6d54e7fb93af"><td class="memItemLeft" align="right" valign="top"><a id="a69bc02c1de12e043494c6d54e7fb93af" name="a69bc02c1de12e043494c6d54e7fb93af"></a>
std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mst</b></td></tr>
<tr class="separator:a69bc02c1de12e043494c6d54e7fb93af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826e2500355f14483c0e102d12413938" id="r_a826e2500355f14483c0e102d12413938"><td class="memItemLeft" align="right" valign="top"><a id="a826e2500355f14483c0e102d12413938" name="a826e2500355f14483c0e102d12413938"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tspTour</b></td></tr>
<tr class="separator:a826e2500355f14483c0e102d12413938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e31e2e7bfe1c0711602b0f943b0c232" id="r_a2e31e2e7bfe1c0711602b0f943b0c232"><td class="memItemLeft" align="right" valign="top"><a id="a2e31e2e7bfe1c0711602b0f943b0c232" name="a2e31e2e7bfe1c0711602b0f943b0c232"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>graphType</b></td></tr>
<tr class="separator:a2e31e2e7bfe1c0711602b0f943b0c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1dd65d6e2541e496031126b75e9c1cb" name="ac1dd65d6e2541e496031126b75e9c1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dd65d6e2541e496031126b75e9c1cb">&#9670;&#160;</a></span>blossomAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; int, int &gt; &gt; Application::blossomAlgorithm </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>oddVertices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the Blossom Algorithm to find perfect matching. </p>
<p>It iteratively constructs augmenting paths by using a priority queue to find the shortest path from an unmatched vertex to any other vertex. The algorithm continues until all odd vertices are matched. The matching edges are then extracted and returned.</p>
<p><b>Complexity</b>: O(E * V^2), where V is the number of vertices and E the number of edges in the graph </p>

</div>
</div>
<a id="a04e3b1094459f877226540af1d8c3240" name="a04e3b1094459f877226540af1d8c3240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e3b1094459f877226540af1d8c3240">&#9670;&#160;</a></span>findEulerianCircuit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Application::findEulerianCircuit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>u</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>circuit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an Eulerian circuit in a graph. </p>
<p>It traverses each edge of the MST, marking it as visited to ensure that no edge is traversed twice. The function then adds the vertices to the circuit vector in a depth-first manner.</p>
<p><b>Complexity</b>: O(E), where E is the number of edges in the graph </p>

</div>
</div>
<a id="ac117d3080e629b82644b0c742e4d3df3" name="ac117d3080e629b82644b0c742e4d3df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac117d3080e629b82644b0c742e4d3df3">&#9670;&#160;</a></span>haversineDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Application::haversineDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>v1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vertex.html">Vertex</a> *</td>          <td class="paramname"><span class="paramname"><em>v2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines Haversine distance between two points. </p>
<p>It makes use of the geographical coordinates of the two vertices and applies the formula to calculate the distance between the two.</p>
<p><b>Complexity</b>: O(log(n)) </p>

</div>
</div>
<a id="a3818802badb48469bff5b57d56d9c13f" name="a3818802badb48469bff5b57d56d9c13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3818802badb48469bff5b57d56d9c13f">&#9670;&#160;</a></span>preorderTraversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Application::preorderTraversal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>root</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>visited</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a preorder traversal starting from a given root node. </p>
<p>It recursively visits each node and adds it to the TSP tour if it hasn't been visited before. The traversal ensures that every vertex in the MST is included in the tour.</p>
<p><b>Complexity</b>: O(V), where V is the number of vertices in the graph </p>

</div>
</div>
<a id="ad12d8561b2200eb51d2f7c275307a779" name="ad12d8561b2200eb51d2f7c275307a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12d8561b2200eb51d2f7c275307a779">&#9670;&#160;</a></span>primMST()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Application::primMST </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prim's algorithm to find Minimum Spanning Tree (MST) of graph. </p>
<p>Uses a priority queue to select the minimum weight edge at each step, ensuring each vertex is included in the MST. The function calculates the total weight of the MST and updates the MST structure.</p>
<p><b>Complexity</b>: O(E * log(V)), where V is the number of vertices and E the number of edges in the graph </p>

</div>
</div>
<a id="ab0c59246a1d8ebdcad2e90b0f8ff04f1" name="ab0c59246a1d8ebdcad2e90b0f8ff04f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c59246a1d8ebdcad2e90b0f8ff04f1">&#9670;&#160;</a></span>tspBacktracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Application::tspBacktracking </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines an optimal solution to the Travelling Salesman Problem. </p>
<p>This function employs a brute-force approach by testing all possible hamiltonian cycles of the graph and displaying the minimum cost found. It keeps track of the current minimum cost and updates it as it finds lower costs. After testing a particular path, it backtracks and starts testing another path.</p>
<p><b>Complexity</b>: O(V!), where V is the number of vertices in the graph </p>

</div>
</div>
<a id="a9dd5f3b4e32963a69ed410037623f0df" name="a9dd5f3b4e32963a69ed410037623f0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd5f3b4e32963a69ed410037623f0df">&#9670;&#160;</a></span>tspBacktrackingAux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Application::tspBacktrackingAux </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>currPos</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>cost</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;</td>          <td class="paramname"><span class="paramname"><em>ans</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auxiliary function to backtracking algorithm. </p>
<p>It recursively explores all possible Hamiltonian cycles, updating the minimum cost and path whenever a lower-cost tour is found. The function backtracks by unmarking vertices and removing them from the path to explore alternative routes.</p>
<p><b>Complexity</b>: O(V!), where V is the number of vertices in the graph </p>

</div>
</div>
<a id="a49cb77f46178b75187daa235a1d86f4f" name="a49cb77f46178b75187daa235a1d86f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cb77f46178b75187daa235a1d86f4f">&#9670;&#160;</a></span>tspChristofides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Application::tspChristofides </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses Christofides' algorithm to solve the Travelling Salesman Problem. </p>
<p>It constructs a Minimum Spanning Tree (MST), finds a minimum weight perfect matching for odd-degree vertices, and combines these to form an Eulerian circuit. The Eulerian circuit is then converted into a Hamiltonian circuit (TSP tour), and the total cost is calculated. If the graph lacks geographical coordinates, the function is not applicable.</p>
<p><b>Complexity</b>: O(E * V^2), where V is the number of vertices and E is the number of edges in the graph </p>

</div>
</div>
<a id="ae6d7f62cef1825295f2012008a9fe963" name="ae6d7f62cef1825295f2012008a9fe963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d7f62cef1825295f2012008a9fe963">&#9670;&#160;</a></span>tspNearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Application::tspNearestNeighbor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the nearest neighbor heuristic to solve the Travelling Salesman Problem. </p>
<p>Starting from the first vertex, it iteratively selects the nearest unvisited vertex until all vertices are visited, then returns to the starting vertex to complete the tour. If the graph lacks geographical coordinates, the function is not applicable.</p>
<p><b>Complexity</b>: O(V^2), where V is the number of vertices in the graph </p>

</div>
</div>
<a id="aca89af62d3a26510836f805d00ce7cab" name="aca89af62d3a26510836f805d00ce7cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca89af62d3a26510836f805d00ce7cab">&#9670;&#160;</a></span>tspRealWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Application::tspRealWorld </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses a nearest neighbor approach to solve the Travelling Salesman Problem in real-world scenarios. </p>
<p>Starting from a given source vertex, it iteratively selects the nearest unvisited vertex until all vertices are visited, then returns to the source to complete the tour. The function calculates and displays the total distance of the tour.</p>
<p><b>Complexity</b>: O(V^2), where V is the number of vertices in the graph </p>

</div>
</div>
<a id="a328fa3aafcf669ef64b19b0867f18689" name="a328fa3aafcf669ef64b19b0867f18689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328fa3aafcf669ef64b19b0867f18689">&#9670;&#160;</a></span>tspTriangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Application::tspTriangular </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polynomial approximation algorithm that relies on the triangular inequality principle. </p>
<p>This function uses a polynomial-time triangular approximation to solve the Travelling Salesman Problem. It constructs a Minimum Spanning Tree (MST) using Prim's algorithm, performs a preorder traversal of the MST to generate a TSP tour, and calculates the total cost. If the graph lacks geographical coordinates, the function is not applicable.</p>
<p><b>Complexity</b>: O(V + E), where V is the number of vertices and E is the number of edges in the graph </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/diogo/dev/DA2324_PRJ2_G85/<a class="el" href="_application_8h_source.html">Application.h</a></li>
<li>C:/Users/diogo/dev/DA2324_PRJ2_G85/<b>Application.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
